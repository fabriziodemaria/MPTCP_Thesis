\section{User Mode Linux}
In order to achieve a reliable reproduction of a real world scenario, the simulation involves the setup of two User Mode Linux (UML) virtual machines running a Linux kernel with enabled support for MPTCP. These two machines act as client and server, carrying on an MPTCP connection that is the target for the ADD\_ADDR attack. 
Using UML to proceed with the experiments allows for very fast setup and boot-up time, with good emulation of real machines and giving the possibility to work on a single hosting machine with no risk of damaging or crashing its underlying kernel.

A good resource in terms of tools, configuration files and kernel images is the official mptcp website:
\textit{http://www.multipath-tcp.org}. In particular, the website offers a python script that downloads all the necessary files to run the two virtual machines. Considering our purpose of verifying the ADD\_ADDR attack feasibility, we don't need to modify or debug the Linux kernel source code, and we can just use the above mentioned components out of the box. At this stage of our analysis it is actually advised to perform the attack on the official distribution as is, and develop external tools for injecting packets and monitoring the status of the connections. More specifically, the MPTCP version adopted for our tests is: \textit{Stable release v0.89.0-rc}.

When executing the script \textit{setup.py} retrieved from the official Website, a few files are downloaded. A \textit{vmlinux} executable file with the MPTCP compatible Linux kernel, two file-systems for the client and the server (\textit{fs\_client} and \textit{fs\_server}) and two shell scripts to configure and run the virtual machines (\textit{client.sh} and \textit{server.sh}). No manual configuration is needed, and client and server should be able to connect via MPTCP right away.
Here it follows the content of the \textit{client.sh} (a similar shell script that is not reported here can be found for the server counterpart, including a single \textit{tap2} interface setup in that case):


\begin{lstlisting}[language=bash, caption=\textit{client.sh}]
#!/bin/bash

USER=`whoami`

sudo tunctl -u $USER -t tap0
sudo tunctl -u $USER -t tap1

sudo ifconfig tap0 10.1.1.1 netmask 255.255.255.0 up
sudo ifconfig tap1 10.1.2.1 netmask 255.255.255.0 up

sudo sysctl net.ipv4.ip_forward=1
sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -j MASQUERADE

sudo chmod 666 /dev/net/tun

./vmlinux ubda=fs_client mem=256M umid=umlA eth0=tuntap,tap0 eth1=tuntap,tap1

sudo tunctl -d tap0
sudo tunctl -d tap1

sudo iptables -t nat -D POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -j MASQUERADE
\end{lstlisting}

With these scripts, it is possible to run the two UML machines and use the local \textit{tap} interfaces to sniff and inject packets (acting, in this specific case, as a physical man in the middle).

The resulting network scenario is graphically depicted in Figure \ref{fig:networkscenario}.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{Network_Scenario}
\caption{Network scenario}
\label{fig:networkscenario}
\end{figure}

By establishing a testing connection via the \textit{iperf} tool, two subflows are automatically generated by MPTCP, from the two interfaces of the client (ip addresses: \textit{10.1.1.2} and \textit{10.1.2.2}) and the single server's interface (with ip address: \textit{10.2.1.2}).

\section{Scapy tool}
In order to carry out the ADD\_ADDR attack it is necessary to inject forged packets into the existing MPTCP flow. In order to do this it is possible to use Scapy, a powerful interactive packet manipulation program that is able to forge or decode packets of a wide number of protocols, send them on the wire, capture them, match requests and replies, and much more [\textit{http://www.secdev.org/projects/scapy}]. Moreover, there exists an unofficial version of Scapy that supports MPTCP and it can be found at the following repository: \textit{https://github.com/nimai/mptcp-scapy}. The Python script that can be used to carry out the ADD\_ADDR attack can be found here: \textit{https://github.com/fabriziodemaria/MPTCP-Exploit}. 

It is appropriate to mention here some of the limitations of the tool (that are examined more in details in Section \ref{limitationsandfuturework}: \textit{Limitations and future work}): the tool has been designed to hijack a specific kind of communication involving client and server sending each others text messages using the tool \textit{netcat}. It is very unlikely that the procedure completes with other kind of MPTCP connection setups between client and server. Nevertheless, this specific exploit serves well our purpose of assessing the danger and feasibility of the ADD\_ADDR attack in general terms.
Moreover, this tool simplify the attack procedure by sniffing the SEQ and ACK numbers of the ongoing connection instead of starting a procedure to try and guess the values. Also, the Ports in use by the client and the server are retrieved automatically by inspecting the sniffed packets, while the IP addresses have to be provided by the user when launching the attack script. Further considerations about these simplifications can be found in Section \ref{limitationsandfuturework}.

The python module \textit{test\_add\_address.py} in the root of the GitHub repository accurately follows the analysis in RFC7430[] to perform the various steps necessary to hijack the MPTCP connection. All the requirements and theoretical details about this procedure have been reported in Section \ref{theaddaddrattack}, and we will limit this section to show and investigate the actual code implementation.

\section{Attack script}
The very first step we need to take care of is the following: we must block all the RST outgoing packets that can be generated by the hosting machine (the attacker) during the process, when the first phases are completing and no finalized TCP connection can be actually detected by the system. This is done with the commands in Listing \ref{norst}.


\begin{lstlisting}[language=python, caption=\textit{Disable RST outgoing packets}, label=norst]
execCommand("sudo iptables -I OUTPUT -p tcp --tcp-flags ALL RST,ACK -j DROP", shell = True)
execCommand("sudo iptables -I OUTPUT -p tcp --tcp-flags ALL RST -j DROP", shell = True)
\end{lstlisting}

The Scapy built-in \textit{sniff} function allows to retrieve packets from a specific interface, according to a custom filter function \textit{filter\_source} that inspects the source address. In this way we can retrieve the IP addresses, Ports, SEQ and ACK numbers of the ongoing connection between client and server.
The first constructive step of the whole procedure consists in forging of the ADD\_ADDR packet using the method \textit{forge\_addaddr} (Listing \ref{forgeaddaddrfunction}).

\begin{lstlisting}[language=python, caption=\textit{forge\_addaddr method}, label=forgeaddaddrfunction] 
def forge_addaddr(myIP, srcIP, srcPort, dstIP, dstPort, sniffedSeq, sniffedAck):
    pkt = (IP(version=4L, src=srcIP, dst=dstIP)/ TCP(sport=srcPort, dport=dstPort, flags="A", seq=sniffedSeq, ack=sniffedAck, options=[TCPOption_MP(mptcp=MPTCP_AddAddr(address_id=ADDRESS_ID, adv_addr=myIP))]))
    return pkt
\end{lstlisting}

Here comes the first consideration about the script design: once the ADD\_ADDR is sent to the victim client, the tool has to be already listening for the MP\_JOIN sent back as a response; in order to make sure this happens, multithreading is used to start looking for the MP\_JOIN packet even before ADD\_ADDR is sent, with the thread named \textit{SYNThread}. \textit{SYNThread} just calls the method \textit{get\_MPTCP\_syn} in the module \textit{sniff\_script.py}, that uses \textit{tcpdump} with a specific filter option. In fact the Scapy \textit{sniff} functionality proves to be unreliable in case of a high flow of packets to be processed and often skips some when the buffers reach their limits. Even if this is fine in other parts of the script, when we need any packet just to inspect ACK and SEQ numbers, we cannot afford to miss the single MP\_JOIN+SYN packet sent by the client upon ADD\_ADDR reception. This problem is also reported in the official Scapy website under the section \say{Known bugs}: \textit{May miss packets under heavy load}.
Note that this wouldn't be a problem with the slow message exchange of \textit{netcat}, but the script can be also tested with high throughput applications like \textit{iperf}, thus the usage of the more reliable \textit{tcpdump}.

In order to filter out exactly the MP\_JOIN packet we are looking for, the following command in Listing \ref{tcpdump} is used, where \textit{tf} is just a temporary file to store the information and \textit{i} is the interface passed as a parameter.

\begin{lstlisting}[language=python, caption=\textit{tcpdump for MP\_JOIN}, label=tcpdump]
execCommand("sudo tcpdump -c 1 -w " + tf.name + ".cap -i " + i + " \"tcp[tcpflags] & tcp-syn != 0\" 2>/dev/null", shell = True)
\end{lstlisting}

A similar sniffing procedure is used for the next steps regarding SYN/ACK and ACK MP\_JOIN packets, as it can be seen for the threads named \textit{SYNACKThread} and \textit{ACKThread}. Each time these sniffing threads are started, a sleep function is called for a time expressed in \textit{THREAD\_SYNC\_TIME}, as a poor but effective mechanism that ensures that \textit{tcpdump} is called and running in the new threads before proceeding.

The MP\_JOIN packets generated and received in this way are manipulated to change the IP addresses and Ports (and possibly other fields) as described in the attack procedure and then forwarded to the right host. Note that manipulating packet's fields in Scapy is different with respect to the case of ADD\_ADDR where the packet is forged from scratch. All the functions \textit{forge\_ack}, \textit{forge\_synack} and \textit{forge\_syn} actually don't forge a new packet but slightly modify a copy of the received packet. While doing this it is necessary to eliminate the Checksum value so that Scapy automatically recalculate the correct value for it, also taking into consideration the updated values. Similar considerations hold for the Ethernet layer of the manipulated packets. 

Once the ACK has been sent to the server, the new subflow is set up. In order to make it more visible, the next steps in the script enable again the outgoing RST packets and forge some of them to close all the subflows apart from the malicious one. By following the \textit{print} messages in the script, this corresponds to \textit{Phase 5}. Now, all the messages from the server to the client are sent to the attacker instead, without an explicit way for the victim to notice. 

The very last portion of the script runs the method \textit{handle\_payload} that both prints the text messages (payload) from the server and generate \textit{data\_ack} packets for the server in order to be able to receive the next packets and keep the connection alive. 

\section{Results, limitations and future work} \label{limitationsandfuturework}

